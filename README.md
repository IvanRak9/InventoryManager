**Design Patterns**
1) **Repository Pattern**

У проєкті реалізовано шаблон проектування Repository, який забезпечує абстракцію доступу до даних. Це дозволяє:

- Ізолювати логіку доступу до бази даних від бізнес-логіки додатку, що спрощує підтримку і тестування.

- Легко підмінювати джерело даних (наприклад, для тестування або зміни типу БД).

- Централізовано реалізувати CRUD-операції для всіх моделей через загальний клас Repository<T>, що забезпечує спільний доступ до даних для різних типів.

- Розширювати функціональність через специфічні репозиторії (наприклад, IProductRepository, ProductRepository для роботи з конкретними сутностями), що дозволяє гнучко додавати методи для окремих моделей, не змінюючи основну реалізацію.

Структура:
1) IRepository<T> – базовий інтерфейс для загальних операцій доступу до даних.

2) Repository<T> – загальна реалізація репозиторія, що використовує IRepository<T>.

3) IProductRepository, ProductRepository – приклади специфічних реалізацій для конкретних моделей, які додають бізнес-логіку.

4) Цей підхід покращує підтримку та масштабованість додатку, дозволяючи легко змінювати і розширювати систему з мінімальними змінами в коді.

2) **MVVM (Model-View-ViewModel)**

У проєкті реалізовано архітектурний шаблон MVVM, який розділяє логіку додатку на три основні компоненти:

- Model (Модель) – представляє структуру та логіку зберігання даних. У проєкті це класи Product, Category, Supplier та Entity Framework InventoryContext, що взаємодіє з базою даних.

- ViewModel (Модель представлення) – містить логіку взаємодії між Model і View. Для кожної сутності (Product, Category, Supplier) створено окрему ViewModel (ProductViewModel, CategoryViewModel, SupplierViewModel), яка:

   - надає дані для прив’язки до інтерфейсу користувача;

   - реалізує CRUD-операції через репозиторії;

   - забезпечує реалізацію INotifyPropertyChanged для оновлення інтерфейсу при зміні даних.

- View (Подання) – XAML-файли (ProductsView.xaml, CategoriesView.xaml, SuppliersView.xaml), які відповідають за візуальне відображення та отримання вводу від користувача. View підключені до ViewModel через Data Binding, не маючи прямого доступу до моделей або логіки обробки.

Завдяки такому розділенню:

1) інтерфейс користувача легко змінювати незалежно від бізнес-логіки;

2) спрощується тестування і супровід коду;

3) код залишається чистим і структурованим.

**Programming principles**
   1) **Принцип єдиного обов'язку (Single Responsibility Principle, SRP):**
      
      У  реалізації патерну Repository кожен клас репозиторію відповідає лише за доступ до даних для конкретної сутності, що дозволяє нам чітко дотримуватися принципу єдиного обов'язку. Це забезпечує ізоляцію логіки доступу до даних від інших аспектів додатку та дозволяє краще організувати код. Замість того, щоб один клас виконував кілька завдань (наприклад, доступ до даних, бізнес-логіка і валідація),  створила окремі репозиторії для кожної сутності, що дозволяє кожному репозиторію зосередитися лише на виконанні операцій CRUD (створення, читання, оновлення, видалення) для відповідної таблиці в базі даних.

Як це реалізовано:
- IRepository<T>: Це базовий інтерфейс, який визначає загальні операції для роботи з базою даних для будь-якої сутності. Він включає методи, такі як Add, GetById, GetAll, Update, Delete. Цей інтерфейс визначає єдину відповідальність – абстрагувати доступ до даних для всіх сутностей.

- Repository<T>: Це загальна реалізація, яка реалізує інтерфейс IRepository<T> та містить загальні методи для роботи з базою даних. Вона не має бізнес-логіки і тільки виконує операції CRUD для конкретних сутностей.

- Специфічні репозиторії (наприклад, ProductRepository): Для кожної сутності, яка потребує специфічних операцій або методів, ми створюємо окремі репозиторії. Наприклад, ProductRepository містить методи, специфічні для роботи з продуктами, а не змішує їх з іншими сутностями. Це дозволяє кожному класу бути відповідальним лише за одну задачу – доступ до даних для конкретної сутності.
2) **DRY (Don't Repeat Yourself)**
  
Цей принцип полягає в усуненні дублювання коду, логіки або функціональності. У проєкті цей принцип реалізовано через:

Generic-репозиторій Repository<T>

Замість того, щоб писати окремо CRUD-операції (Create, Read, Update, Delete) для кожної сутності (Product, Category, Supplier), я винесла спільну логіку в універсальний клас-репозиторій:

 public class Repository<T> : IRepository<T> where T : class
 {
   protected readonly InventoryContext _context;
   protected readonly DbSet<T> _dbSet;

   public Repository(InventoryContext context)
   {
     _context = context;
     _dbSet = _context.Set<T>();
   }

   public IEnumerable<T> GetAll() => _dbSet.ToList();

   public T GetById(int id) => _dbSet.Find(id); 

   public void Add(T entity)
   {
     _dbSet.Add(entity);
     _context.SaveChanges();
   }
   public void Update(T entity)
   {
     _dbSet.Update(entity);
     _context.SaveChanges();
   }

   public void Delete(T entity)
   {
     _dbSet.Remove(entity);
     _context.SaveChanges();
   }
 }
 
У разі необхідності — наприклад, для ProductRepository — я розширюю базовий функціонал, не дублюючи загальні методи.

- Перевага: менше повторень, легше оновлювати і тестувати, зміни в логіці CRUD впливають лише на одне місце.
3) **KISS (Keep It Simple, Stupid)**
  Цей принцип закликає уникати зайвої складності. У вашому застосунку він реалізований через:

✅ Чітка структура проєкту

Models — лише дані (без логіки).

ViewModels — логіка для в’ю.

Views — тільки візуальне представлення (UI).

Repositories — інкапсульований доступ до БД.

Interfaces — чітке розділення контрактів.

✅ Простота у використанні WPF

Ви використовуєте двосторонню прив’язку ({Binding}) для зв’язку між View та ViewModel.

✅ Простий механізм оновлення даних

CRUD виконується простими методами: AddProduct, UpdateProduct, DeleteProduct, що не містять зайвої логіки.

Усі оновлення автоматично відображаються в UI через INotifyPropertyChanged.

**Refactoring Techniques**

У проєкті використовувались наступні техніки рефакторингу для покращення якості, читабельності та підтримуваності коду:

1. Extract Class
   
Було виділено окремі класи для репозиторіїв (ProductRepository, CategoryRepository тощо), щоб ізолювати логіку доступу до даних.

3. Move Method

CRUD-методи були перенесені з ViewModel у відповідні репозиторії, що дозволяє зосередити логіку доступу до БД в одному місці.

5. Encapsulate Field

Використано властивості (public Property { get; set; }) замість прямого доступу до полів, що забезпечує контроль над доступом до даних.

7. Replace Magic Numbers/Strings with Constants

Константи та ідентифікатори збережені в окремих файлах (наприклад, enum або static class), щоб уникнути "магічних значень".

8. Use Dependency Injection

Залежності (репозиторії) передаються через конструктори до ViewModel, що робить їх легко замінними та тестованими.

9. Remove Dead Code

Під час розробки видалено тимчасовий або неактуальний код, що покращило чистоту проєкту.

10. Rename for Clarity

Імена класів, змінних і методів були змінені для кращої зрозумілості (наприклад, AddProduct() замість BtnClick()).


  
